from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import FileResponse
from sqlalchemy.orm import Session
import models, schemas, database, auth
import os
from docx import Document
from pptx import Presentation
import tempfile

router = APIRouter(
    prefix="/export",
    tags=["export"],
)

@router.get("/{project_id}")
def export_document(project_id: int, db: Session = Depends(database.get_db), current_user: models.User = Depends(auth.get_current_user)):
    project = db.query(models.Project).filter(models.Project.id == project_id, models.Project.user_id == current_user.id).first()
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    contents = db.query(models.Content).filter(models.Content.project_id == project_id).order_by(models.Content.section_order).all()
    
    if project.doc_type == "docx":
        return export_docx(project, contents)
    elif project.doc_type == "pptx":
        return export_pptx(project, contents)
    else:
        raise HTTPException(status_code=400, detail="Invalid document type")

from pptx.util import Pt
from pptx.enum.text import MSO_AUTO_SIZE

# ... imports ...

def export_docx(project, contents):
    doc = Document()
    style = doc.styles['Normal']
    font = style.font
    font.name = 'Calibri'
    font.size = Pt(11)
    
    doc.add_heading(project.title, 0)
    
    for content in contents:
        doc.add_heading(content.title, level=1)
        if content.content_text:
            # Basic Markdown parsing
            lines = content.content_text.split('\n')
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                
                if line.startswith('# '):
                    doc.add_heading(line[2:], level=2)
                elif line.startswith('## '):
                    doc.add_heading(line[3:], level=3)
                elif line.startswith('### '):
                    doc.add_heading(line[4:], level=4)
                elif line.startswith('* ') or line.startswith('- '):
                    p = doc.add_paragraph(style='List Bullet')
                    add_formatted_text(p, line[2:])
                else:
                    p = doc.add_paragraph()
                    add_formatted_text(p, line)
            
    # Save to temp file
    fd, path = tempfile.mkstemp(suffix=".docx")
    os.close(fd)
    doc.save(path)
    
    return FileResponse(path, filename=f"{project.title}.docx", media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document")

def add_formatted_text(paragraph, text):
    """Helper to add text with bold formatting (**text**)"""
    parts = text.split('**')
    for i, part in enumerate(parts):
        run = paragraph.add_run(part)
        run.text = part
        run.font.name = 'Calibri'
        if i % 2 == 1: # Odd parts are between ** and **
            run.bold = True

def export_pptx(project, contents):
    prs = Presentation()
    
    # Title Slide
    slide_layout = prs.slide_layouts[0] 
    slide = prs.slides.add_slide(slide_layout)
    title = slide.shapes.title
    subtitle = slide.placeholders[1]
    title.text = project.title
    subtitle.text = "Generated by AI Document Generator"
    
import textwrap

# ... (keep existing imports)

def export_pptx(project, contents):
    prs = Presentation()
    
    # Title Slide
    slide_layout = prs.slide_layouts[0] 
    slide = prs.slides.add_slide(slide_layout)
    title = slide.shapes.title
    subtitle = slide.placeholders[1]
    title.text = project.title
    subtitle.text = "Generated by AI Document Generator"
    
    for content in contents:
        if not content.content_text:
            # Create empty slide with title
            create_slide(prs, content.title, "")
            continue

        # Split content into chunks
        # 1. Split by newline first
        raw_lines = content.content_text.split('\n')
        
        # 2. Wrap long lines to ensure they don't exceed slide width roughly
        # Assuming ~80-100 chars per line for Font 24
        wrapped_lines = []
        for line in raw_lines:
            line = line.strip()
            if not line:
                continue
            # Skip headers/labels
            if line.startswith('#') or line.lower().startswith('slide ') or line.lower().startswith('title:'):
                continue
                
            if len(line) > 80:
                wrapped_lines.extend(textwrap.wrap(line, width=80))
            else:
                wrapped_lines.append(line)

        chunks = []
        current_chunk = []
        current_char_count = 0
        
        # Stricter limits for Font 24
        MAX_CHARS = 500 
        MAX_LINES = 9
        
        for line in wrapped_lines:
            # Check if adding this line exceeds limits
            if (current_char_count + len(line) > MAX_CHARS) or (len(current_chunk) >= MAX_LINES):
                if current_chunk:
                    chunks.append(current_chunk)
                current_chunk = [line]
                current_char_count = len(line)
            else:
                current_chunk.append(line)
                current_char_count += len(line)
        
        if current_chunk:
            chunks.append(current_chunk)
            
        # Create slides for each chunk
        for i, chunk in enumerate(chunks):
            slide_title = content.title if i == 0 else f"{content.title} (Cont.)"
            create_slide(prs, slide_title, chunk)
            
    # Save to temp file
    fd, path = tempfile.mkstemp(suffix=".pptx")
    os.close(fd)
    prs.save(path)
    
    return FileResponse(path, filename=f"{project.title}.pptx", media_type="application/vnd.openxmlformats-officedocument.presentationml.presentation")

def create_slide(prs, title_text, lines):
    slide_layout = prs.slide_layouts[1] # Title and Content
    slide = prs.slides.add_slide(slide_layout)
    title = slide.shapes.title
    body = slide.placeholders[1]
    
    title.text = title_text
    
    tf = body.text_frame
    tf.clear() 
    tf.auto_size = MSO_AUTO_SIZE.TEXT_TO_FIT_SHAPE
    tf.word_wrap = True
    
    if isinstance(lines, str):
        lines = [lines] if lines else []

    for line in lines:
        p = tf.add_paragraph()
        p.font.name = 'Calibri'
        p.font.size = Pt(24) # Start larger, let auto-fit handle it
        
        # Handle bullets
        if line.startswith('* ') or line.startswith('- '):
            p.level = 0
            clean_text = line[2:]
        elif line.startswith('  * ') or line.startswith('  - '):
            p.level = 1
            clean_text = line[4:]
        else:
            p.level = 0
            clean_text = line
        
        # Handle bold
        parts = clean_text.split('**')
        for i, part in enumerate(parts):
            run = p.add_run()
            run.text = part
            run.font.name = 'Calibri'
            if i % 2 == 1:
                run.font.bold = True
